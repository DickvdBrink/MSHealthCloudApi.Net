import * as fs from "fs";
import Formatter from "./formatter";

const config = JSON.parse(fs.readFileSync("config.json", "utf-8"));
const content = fs.readFileSync(config.input, "utf-8");
const api: Swagger = JSON.parse(content);

const namespace = config.namespace;
const enumTypes: { [index: string]: { items: string[] } } = {};

console.log("Generating types for: " + api.info.title);

const keys = Object.keys(api.definitions);
for (const key of keys) {
    if (key == "Object") continue;

    const definition = api.definitions[key];
    const classTemplate = `// This file is automatically generated
using System;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace ${namespace}
{
    /// <summary>
    /// ${formatDescription(definition.description, Array(4 + 1).join(" "))}
    /// </summary>
    public class ${key}${implementsInterface(key, definition)}
    {
${createProperties(definition)}
    }
}`;
    fs.writeFileSync(`${config.outputFolder}/${key}.cs`, classTemplate);
}

const enumkeys = Object.keys(enumTypes);
for (const key of enumkeys) {
    const definition = enumTypes[key];
    const enumTemplate = `// This file is automatically generated
using System;

namespace ${namespace}
{
    public enum ${formatName(key)}
    {
        ${definition.items.join(",\n        ")}
    }
}`;
    fs.writeFileSync(`${config.outputFolder}/${formatName(key)}.cs`, enumTemplate);
}

function createProperties(definition: SwaggerSchema) {
    const keys = Object.keys(definition.properties);
    let result = "";
    for (const key of keys) {
        const property = definition.properties[key];
        if (property.description) {
            result += `        /// <summary>
        /// ${formatDescription(property.description, Array(8 + 1).join(" "))}
        /// </summary>\n`;
        }

        result += `        [JsonPropertyAttribute("${key}")]\n`;
        result += `        public ${dataTypeToCSharp(property, key)} ${formatName(key)} { get; set; }\n`;
    }
    return result;
}

function implementsInterface(key: string, definition: SwaggerSchema) {
    for (var item in config.interfaces) {
        var t = config.interfaces[item];
        if (t.implementors && typeof t.implementors == "object"
        && t.implementors.regex) {
            var re = new RegExp(t.implementors.regex);
            if (re.test(key)) {
                return `: ${item}`;
            }
        }
    }
    return "";
}

function dataTypeToCSharp(property: SwaggerProperty, key: string) {
    const map: { [index: string]: string | { [index: string]: string } } = {
        'integer': {
            'int32': 'int',
            'int64': 'long'
        },
        'number': {
            'float': 'float',
            'double': 'double'
        },
        'string': {
            'byte': 'byte[]',
            'binary': 'byte[]',
            'date': 'DateTime',
            'date-time': 'DateTime',
            'password': 'string',
        },
        'boolean': 'bool'
    };
    if ((<any>property).enum) {
        enumTypes[key] = { items: (<any>property).enum };
        return formatName(key);
    }
    if (property.type == "array" || property["$ref"]) {
        const ref = property["$ref"] || <string>property["items"]["$ref"];
        const name = ref.substring(ref.lastIndexOf('/') + 1)
        return (property.type == "array" ? `List<${name}>` : name);
    }
    const result = map[property.type];
    if (typeof result === "string") {
        return result;
    } else if (result && property.format && result[property.format]) {
        return result[property.format];
    } else {
        return 'string';
    }
}

function formatDescription(description: string, indent: string) {
    if (description) {
        return description.replace(/(\r\n|\n|\r)[ ]*/g, "$1" + indent + "/// ");
    }
    return "";
}

function formatName(name: string) {
    return name.replace(/^./, (str) => str.toUpperCase());
}